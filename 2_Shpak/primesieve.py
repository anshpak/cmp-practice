# Упражнение: Напишите программу primesieve.py, которая для заданного n (по умолчанию n=10) 
# выдает массив простых чисел от 2 до n просеиванием решета Эратосфена. Этот метод работает так:
# сначала записываем все числа 2,3,4,5,...,n
# первое число (2) будет простым -- вычеркиваем все, делящиеся на 2, остаются 3,5,7,9,...n
# первое число (3) будет простым -- вычеркиваем все, делящиеся на 3,
# остаются 5,7,11,...n
# продолжаем в том же духе пока не просеем все числа

import sys

if len(sys.argv) == 1:
	n = 10
else:
	n = int(sys.argv[1])

lst = list(range(2, n + 1))
ln = len(lst)
for_remove = set()

# очень существенный минус такого подхода, как описанный ниже, - проход повторно по тем элементам, который должны быть удалены уже
# например, 8 нужно удалить на этапе проверки остатка при делении 8 на 2, но она еще будет проверяться и в следующих итерациях
# и даже добавится ещё раз в множество (для этого оно и используется)

# for i in range(n - 1):
# 	for el in lst[i + 1:]:
# 		if el % lst[i] == 0:
# 			for_remove = for_remove | {el}

# # или же формировать строку
# res = []
# for el in lst:
# 	if el in for_remove:
# 		continue
# 	res += [el]

# ниже все работает хорошо, потому что я удаляю элементы следующие за текущим "проверяемым" элементом
# и, так как, как оказалось, el проходитсяпо списку lst с учетом всех изменений, то есть с недавними удалениями, например,
# я не повторяюсь и не проверяю повторно лишние элементы, как это было выше

for el in lst:
	for n_el in lst[lst.index(el) + 1:]:
		if n_el % el == 0:
			lst.remove(n_el)

print(lst)